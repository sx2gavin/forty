---
layout: post
title: Portals
image: assets/images/portals/portals-view.png
date: 2020-05-23 13:08:00 -0500
---

I saw a video on YouTube by [Sebastian Lague](https://www.youtube.com/user/Cercopithecan) called [Coding Adventure: Portals](https://www.youtube.com/watch?v=cWpFZbjtSQg), I thought the topic was really interesting so I've decided to follow along and try to implement my own version of the portals. Computer Graphics and rendering are always a big interest of mine so I wanted to use this opportunity to learn about rendering in general, as well as some Shader coding in Unity. In this article I've documented all the steps I did in order to achieve the same portal effects in the video. I will also have a link to my Github repo here: [Portals](https://github.com/sx2gavin/Portals) in case anybody wants to check it out.

# The Whole Process of Creating Portals
## Step 1. Basic Scene Setup
For this simple scene, I created two huge platforms, one in blue and one in red, and some randoms cubes on the platforms so I will know what I'm currently looking at. For the cubes I just used ProBuilder in Unity to quickly create a couple of them.

![Scene-Setup]({{ site.baseurl }}/assets/images/portals/scene-setup.png)

In order for me to move around in the scene, I've also created a first-person controller to allow moving and looking around in the scene. It has a Capsule Collider, a Rigidbody and a First Person Character Controller script attached to it. Main camera is attached to this controller as a child so we will be able to control camera movement.

![first-person-controller]({{ site.baseurl }}/assets/images/portals/first-person-controller.png)

For the `FirstPersonCharacterController.cs`, I had some very simple code to control the movement and the camera:
```
    void Update()
    {
        if (Input.GetButtonDown("Jump"))
        {
            rigidbody.AddForce(new Vector3(0, jumpForce, 0));
        }

        var direction = new Vector3(-Input.GetAxis("Mouse Y"), Input.GetAxis("Mouse X"), 0);
        var angles = camera.transform.rotation.eulerAngles;
        angles += direction;
        camera.transform.rotation = Quaternion.Euler(angles);

        var movement = new Vector3(Input.GetAxis("Horizontal"), 0, Input.GetAxis("Vertical"));
        if (movement.magnitude > double.Epsilon)
        {
            var yaw = Quaternion.Euler(new Vector3(0, angles.y, 0));
            movement = yaw * movement;
            rigidbody.velocity = movement * Time.deltaTime * speed + new Vector3(0, rigidbody.velocity.y, 0);
        }
        else 
        {
            rigidbody.velocity = new Vector3(0, rigidbody.velocity.y, 0);
        }
    }
```

The basic setup is done and now we can move and jump in the scene. Now comes the tricky part which is making the portals.

## Step 2. Portal Rendering
There are two major functionalities that the portal needs to have: render what the other portal sees onto this portal, and teleporting objects. For this step we are going to try to use some camera tricks to render the portal.

![two-portals]({{ site.baseurl }}/assets/images/portals/two-portals.png)

First, I created two portals, one on each platform, in order to see what the other portal sees, I attached a new camera on each portal, this camera will be responsible for rendering the scene from the opposite portal. But instead of rendering the camera to the screen, I wanted the camera to render to the portal. 

### Target Texture
Unity had a really nice feature of rendering camera to a texture called [Target Texture](https://docs.unity3d.com/ScriptReference/Camera-targetTexture.html). 

**PortalCamera.cs:**
```
viewTexture = new RenderTexture(Screen.width, Screen.height, 0);
portalCamera.targetTexture = viewTexture;
```

Basically if you set the target texture to some texture, this camera will render to this texture. That's exactly what I wanted. I then assign the texture to the portal's material so the portal will render what the camera sees.

**PortalDisplay.cs:**
```
material = GetComponent<Renderer>().material;
material.SetTexture("_MainTex", viewTexture);

```

### Manual Camera Rendering
In the meantime, I did't want the portal cameras to render every frame because it is really GPU heavy, I only wanted them to render when the main camera can see the portal, then I can tell the camera to render manually. In order to manually render cameras, I had to disable the camera, and call `Render()` function explicitly when rendering is needed. Unity documentation briefly mentioned this feature for [Render()](https://docs.unity3d.com/ScriptReference/Camera.Render.html).

**PortalCamera.cs:**
```
void Start()
{
    portalCamera.enabled = false;
}

public void Render()
{
    portalCamera.Render();
}

```
